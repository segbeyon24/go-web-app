## Build and run the app locally

1. run the application, review the app, understand the app

2. create a multi-stage dockerfile for the app, ensure your base go-image version is >= 1.22.5

3. build it: 
   ```docker build -t segbeyon/devops_go:v1 . ```

4. run container: 
``` docker run -p 8080:8080 -it <docker_username>/<image_name>:<tag > ```

5. stop the container and push to docker hub
   ``` docker push <docker_username>/<image_name>:<tag > ```


## Kubernetes

1. Create a k8s folder and create a "manifests" folder in it

2. create deployment, services and ingress resources
   - other resoures you can add include cronjob
   - ensure the labels are the same with the one in the 
     selector of the service resource

3. install kubectl, awscli (configure), eksctl
   - try doing this with terraform

4. create eks cluster: "eksctl create cluster --name demo-cluster --region us-east-1"

5. deploy all the manifests

6. edit the service 
   ```kubectl edit svc <name>```
   - change the type form ClusterIP to NodePort

7. run "kubectl get nodes -o wide"
   - this should display 2 nodes with internal and external IPs
   - copy the external IP of any of the 2 nodes with the node Port on a web browser, this should display the app

8. Install nginx ingress controller:
   - ```kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/controller-v1.11.1/deploy/static/provider/aws/deploy.yaml```

   ```kubectl get pods -n ingress-nginx```

   - ```kubectl edit pod <name_of_running_pod> -n ingress-nginx``` 
        
   - note the name of the ingressClassName

   - run: 
     ```kubectl get ing``` 
     check if the controller should have created a load balancer with the ingress resource and load-balancer dns address

9. the web app will not display on the browser. This is because the the dns is not the
   same string with the spec.roles.host address (go-web-app.local or example.com) that
   you provided. So we will map the IP address of the spec.roles.host address to the 
   LB IP address 

   - copy the lb-address, run: 
     ```nslookup [the_lb_address]``` 

     copy the address in the output of:

    ```sudo vim /etc/hosts```

   - paste it in the file, press the spacebar key and type your spec.roles.host address

   - now, when the lb dns address is copied on the browser, it displays the app.
     
   - delete all the deployments.


## Helm

1. install helm

2. create a helm folder in the root dir and cd into it # delete the charts

3. run: 
   ```helm create go-web-app-chart```

4. delete all the files in the templates folder. copy the manifests in the k8s folder to the templates folder

5. open the deployment.yml file and change the tag (v1) to 
   `{{ Values.image.tag }}`
   - whenever the helm is executed, it will look for the tag in the values.yml file
   - change the image.tag in the Values.yml file to "'v1'"

6. run 
   ```helm install go-web-app ./go-web-app-chart``` 
   
   This installs all the resources
      ```kubectl edit deploy go-web-app``` 
   
   - check and notice that helm has replaced the tag of the image with the value of the tag in the values.yml file

7. Uninstall everything: 
   ```helm uninstall go-web-app```



## Continuous Integration (CI) (tool: git actions)

1. create .github/workflow/ci.yml file

2. git add, commit and push (note that the ci process was set to start on push)

3. The goal is to update the Registry (docker hub) with the latest git changes, the change
   creates a new image tag (set to the github.run_id generated by the gitaction ci proccess), and updates the git repository with the new tag.



## Continuous Delivery (ArgoCD)

1. Install and setup argocd (check the `gitOps` directory)

2. copy the lb-address from the output of this command:
   - kubectl get svc argocd-server -n argocd
   - paste it on the web browser
   - argocd should come up

3. Alternatively:
   - run "kubectl get nodes -o wide"
   - copy the external IP of any of the nodes, paste it on a browser
   - copy the port of the load balancer and paste it beside the node Port
     - i.e [Node_IP]:[lb_port]
     -argocd should come up

4. Username is "admin", to get the password:
   - run 
     ```kubectl get secrets -n argocd```
   - run 
      ```kubectl edit secret argo-cd-initial-admin-secret -n argocd```
   - copy the password # it is base64 encoded

   - run 
     ```echo <password> | base64 --decode>```

   - copy the output and paste it in the password of argocd on the browser ignore any `%` if occurs at the end of the password

5. On argocd, 
   - click on "new app"
   - enter the name of the app `go-web-app`
   - default
   - Automatic
   - check "self-heal"
   - source: paste the repo url
   - it would autofill the Path with helm/go-web-app-chart
   - cluster url: click on the drop-down and pick the only option
   - Namespace: type "default"
   - Value file: choose the value.yml file
   - click on create

7. Argocd deploys all the resources, which you can view the pods on the UI
   - you can view the pods on cli with get commands
     ```kubectl get ing```
   - copy the hosts address (go-web-app.local)
   - paste it on the crowser with /courses, or /about, the app should display

8. Now, when changes are made and pushed to the repo:
   - a new docker image is built and tagged
   - code-quality is checked
   - the image is pushed to registry (docker hub)
   - the repo's helm chart is updated with the new tag # generated from the ci process
   - you can check to verify
   - argocd watches for changes. run "kubectl edit deploy go-web-app"
   - notice, argocd should have updated the image tag
   - the changes should be updated on the app 
   - check the app on the browser
